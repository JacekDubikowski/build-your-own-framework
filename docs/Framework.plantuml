@startuml
interface BeanDefinition<T> {
 T create(BeanProvider beanProvider)
 Class<T> type()
}

class BeanA
class BeanB
class BeanC

class $BeanA$Definition {
    provider : ScopeProvider<BeanA>
}
class $BeanB$Definition {
    provider : ScopeProvider<BeanB>
}
class $BeanC$Definition {
    provider : ScopeProvider<BeanC>
}

$BeanA$Definition --> BeanA : publishes definition
$BeanB$Definition --> BeanB : publishes definition
$BeanC$Definition --> BeanC : publishes definition

BeanDefinition <|-- $BeanA$Definition
BeanDefinition <|-- $BeanB$Definition
BeanDefinition <|-- $BeanC$Definition

interface BeanProvider<T> {
    T provide(Class<T> beanType)

    Iterable<T> provideAll(Class<T> beanType)
}

interface ScopeProvider<T> {
    T apply(BeanProvider beanProvider)
}

class SingletionScopeProvider<T>

SingletionScopeProvider --|> ScopeProvider

class BeanProviderFactory {
    {static} BeanProvider getInstance(...)
}

BeanProviderFactory --> BaseBeanProvider : create
BeanProviderFactory --> BeanProvider : return
BaseBeanProvider o-- BeanDefinition
BaseBeanProvider --|> BeanProvider

class BeanProcessor
abstract class AbstractProcessor

BeanProcessor --|> AbstractProcessor

note "BeanProcessor writes the source for $BeanA$Definition, $BeanB$Definition, $BeanC$Definition" as N1
N1 -- BeanProcessor
N1 -- $BeanA$Definition
N1 -- $BeanB$Definition
N1 -- $BeanC$Definition
@enduml

